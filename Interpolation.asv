classdef Interpolation
    methods(Static)
        %% INTERPOLATION TOOLKIT
        % Written by Curtis Aquino (2019). Contains:
        % 
        % # PiecewiseLinearInterpolation() performs linear piecewise interpolation given x- and y-data.
        % # CubicSplinePlus() uses MATLAB's spline() function but endogenously turns it into a piecewise symbolic function.
        % # SchumakerSpline() implements the shape-preserving spline proposed by Schumaker.
        
%% PIECEWISELINEARINTERPOLATION
function F = PiecewiseLinearInterpolation(x,y,x0)
    [~,idx] = sort(x);
    x       = x(idx);
    y       = y(idx);
    bds     = [x(1:(end-1)),x(2:end)];
    n       = length(x);
    m       = length(x0);
    a       = (y(2:n) - y(1:(n-1)))./(x(2:n)-x(1:(n-1)));
    b       = (y(1:(n-1)).*x(2:n)-y(2:n).*x(1:(n-1)))./(x(2:n)-x(1:(n-1)));
    for i = 1:m
        idx     = find(bds(:,1) <= x0(i) & x0(i) <= bds(:,2));
        if length(idx) > 1
            idx     = find(bds(:,1) <= x0(i) & x0(i) < bds(:,2));
        end
        if isempty(idx)
            if x0(i) < x(1)
                F(i) = x(1);
            elseif x0(i) > x(end)
                F(i) = x(end);
            end
        else
            F(i)    = a(idx)*x0(i)+b(idx);
        end
    end
end
%% CUBICSPLINEPLUS
function CubicSplinePlus(X,Y)
    temp        = spline(X,Y);
    F           = sum(temp.coefs.*(sym('X')-X(1:(end-1))').^(3:-1:0),2); %#ok<NASGU>
    % Endogenous Piecewise
    syms X
    Text = sprintf('piecewise(');
    for i = 1:(length(temp.breaks)-1)
        if i == (length(temp.breaks)-1)
            Text = [Text, sprintf('temp.breaks(%i) <= X & X <= temp.breaks(%i),F(%i))',i,i+1,i)];       %#ok<*AGROW>
        elseif i == 1
            Text = [Text, sprintf('temp.breaks(%i) <= X & X <= temp.breaks(%i),F(%i),',i,i+1,i)];       %#ok<*AGROW>
        else
            Text = [Text, sprintf('temp.breaks(%i) <= X & X <= temp.breaks(%i),F(%i),',i,i+1,i)];
        end
    end
    F = eval(Text); %#ok<NASGU>
end
%% SCHUMAKERSPLINE
function F = SchumakerSpline(X,Y,X0)
    
    % Fixes user inputs
    if isrow(X0); X0 = X0'; end
    if isrow(X); X = X'; end
    if isrow(Y); Y = Y'; end
    [~,idx]     = sort(X);
    X           = X(idx);
    Y           = Y(idx);
    
    % Build what Iqbal (1992) calls the Butland formulas
    del     = (Y(2:end)-Y(1:(end-1)))./(X(2:end)-X(1:(end-1)));
    temp1   = del(2:end).*del(1:(end-1));
    d       = ((2*temp1)./(del(2:end)+del(1:(end-1)))).*(temp1>0);
    d1      = (2*del(1)-d(1)).*(del(1)*(2*del(1)-d(1))>0);
    dn      = (2*del(end)-d(end)).*(del(end)*(2*del(end)-d(end))>0);
    d       = [d1;d;dn];
    
    % Builds what Iqbal (1992) calls xi and dbar
    xi1c    = ((d(2:end)-delta).*(d(1:(end-1))-delta))<0;
    xi2c    = ((d(2:end)-delta).*(d(1:(end-1))-delta))>=0;
    xi1     = X(2:end)+(d(1:(end-1))-delta).*(X(2:end)-X(1:(end-1)))./(d(2:end)-d(1:(end-1)));
    xi2     = (X(1:(end-1))+X(2:end))/2;
    xi      = xi1.*xi1c+xi2.*xi2c;
    dbar    = (2*delta-d(2:end))+(d(2:end)-d(1:(end-1))).*(xi-X(1:(end-1)))./(X(2:end)-X(1:(end-1)));
    
    % Builds all of the coefficients
    Coef.A  = [Y(1:(end-1)),Y(1:(end-1)),Y(1:(end-1))+d(1:(end-1)).*(xi-X(1:(end-1)))+(dbar-d(1:(end-1))).*(xi-X(1:(end-1)))/2];
    Coef.B  = [d(1:(end-1)),d(1:(end-1)),dbar];
    Coef.C  = [0.5*(d(2:end)-d(1:(end-1)))./(X(2:end)-X(1:(end-1))),0.5*(dbar-d(1:(end-1)))./(xi-X(1:(end-1))),0.5*(d(2:end)-dbar)./(X(2:end)-xi)];
    
    % Checks which points need interior knots
    intknot = d(1:(end-1))+d(2:end) == 2*delta;
    
    % Builds coefficients and ranges
    Range = []; Coefs = [];
    for i = 1:length(intknot)
        if intknot(i) == 1
            Range   = [Range;[X(i),X(i+1)]];
            Coefs   = [Coefs;Coef.A(i,1),Coef.B(i,1),Coef.C(i,1)];
            
        else
            Range   = [Range;[X(i),xi(i)];[xi(i),X(i+1)]];
            Coefs   = [Coefs;Coef.A(i,2),Coef.B(i,2),Coef.C(i,2)];
            Coefs   = [Coefs;Coef.A(i,3),Coef.B(i,3),Coef.C(i,3)];
        end
    end
    
    for i = 1:size(X0,1)
        Coefs(Range(:,1) <= X0(i) & X0(i) <= Range(:,2)
        
        
        sum(Coefs.*[ones(size(Coefs,1),1),(X0(i)-Range(:,1)),(X0(i)-Range(:,1)).^2],2);
    end
    
    
    
end
    end
end