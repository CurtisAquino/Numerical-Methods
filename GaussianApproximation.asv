classdef GaussianApproximation
    methods(Static)
        %% GAUSSIANAPPROXIMATION TOOLKIT
        % Written by Curtis Aquino (2019)
        % Contains:
        %   1. Initialization():
        %       This function is required for all functions to run.
        %
        %   2. SymbolicPolynomial()
        %
        %   3. NumericPolynomial()
        %
        %   4. SymoblicNodesWeights()
        %
        %   5. NumericNodesWeights()
        %
        %   4. Interpolate()
        %
        
%% 1. INITIALIZATION      
% 
%==========================================================================
function [T,Spprt]      = Initialization(GaussianPolynomial)
    Types   = {
            'Gauss-Legendre';...
            'Gauss-Chebyshev';...
            'Gauss-Hermite';...
            'Gauss-Laguerre'
            };
    T       = find(strcmp(GaussianPolynomial,Types));
    Spprt   = length(Types);
end

%% 2. SYMBOLICPOLYNOMIAL
% Creates symbolic expressions for the first N polynomials for a class of 
% Gaussian polynomials. For Gaussian polynomials without analytical
% expressions, this will become slow for very high order polynomials.
%==========================================================================
function Polynomial     = SymbolicPolynomial(PolynomialOrder,GaussianPolynomial)
    
    [T,~]           = GaussianApproximation.Initialization(GaussianPolynomial);
    N               = PolynomialOrder+1;
    X               = sym('X','real');
    Polynomial      = sym(zeros(N,1));
    Polynomial(1)   = 1;
    
    if T == 1
       Coef     = [[0,0,X.*(2.*(1:N)+1)./(2:(N+1))];[0,0,(1:N)./(2:(N+1))]];
       Polynomial(2) = X;
    end 
    
    if T == 2
       Coef     = [[0,0,repmat(2*X,1,N)]; [0,0,ones(1,N)]];
       Polynomial(2) = X;
    end
        
    if T == 3
       Coef     = [[0,0,repmat(2*X,1,N)]; [0,0,2*(1:N)]];
       Polynomial(2) = 2*X;
    end
    
    if T == 4
       Coef     = [[0,0,(2.*(1:N)+1-X)./(2:(N+1))];[0,0,(1:N)./(2:(N+1))]];
       Polynomial(2) = 1-X;
    end
    
    for i = 3:N
       Polynomial(i) =  Coef(1,i)*Polynomial(i-1)-Coef(2,i)*Polynomial(i-2);
    end
end

%% 2. NUMERICPOLYNOMIAL
% Returns numerical solutions for the first N polynomials for a class of 
% Gaussian polynomials evaluated at a set of points. This method is very
% fast for even high order polynomials as no symbolic calculations are
% performed. 
%==========================================================================
function Polynomial     = NumericPolynomial(PolynomialOrder,GaussianPolynomial,X)
    
    % Initialization
    [T,~]           = GaussianApproximation.Initialization(GaussianPolynomial);
    N               = PolynomialOrder+1;
    XLen            = length(X);
    Polynomial(:,1) = ones(XLen,1);
    
    % Fixes input size
    if isrow(X); X = X'; end
    
    % Initialize each Gaussian polynomial
    if T == 1
       Coef(:,:,1) = [zeros(XLen,2),(X.*(2.*(1:N)+1))./(2:(N+1))]; 
       Coef(:,:,2) = repmat([0,0,(1:N)./(2:(N+1))],XLen,1);
       Polynomial(:,2) = X;
    end 
    if T == 2
       Coef(:,:,1) = [zeros(XLen,2),repmat(2*X,1,N)];
       Coef(:,:,2) = repmat([0,0,ones(1,N)],XLen,1);
       Polynomial(:,2) = X;
    end
    if T == 3
       Coef(:,:,1) = [zeros(XLen,2),repmat(2*X,1,N)];
       Coef(:,:,2) = repmat([0,0,2*(1:N)],XLen,1);
       Polynomial(:,2) = 2*X;
    end
    if T == 4
       Coef(:,:,1) = [zeros(XLen,2),(2.*(1:N)+1-X)./(2:(N+1))]; 
       Coef(:,:,2) = repmat([0,0,(1:N)./(2:(N+1))],XLen,1);
       Polynomial(:,2) = 1-X;
    end
    
    % Recursion relation
    for i = 3:N
       Polynomial(:,i) = Coef(:,i,1).*Polynomial(:,i-1)-Coef(:,i,2).*Polynomial(:,i-2);
    end
    
    % Output table
    for i = 1:N
        ColName{i} = sprintf('Degree%i',i-1); %#ok<AGROW>
    end
    Polynomial  = array2table(Polynomial,'VariableNames',ColName);%,'RowNames',strcat('X=',cellstr(num2str(X))));
end

%% 3. SYMBOLICNODESWEIGHTS
% Finds the nodes and weights for a variety of Gaussian polynomials using
% MATLAB's symbolic solver. It is very accurate, but slow for high order
% polynomials.
%==========================================================================
function [Nodes,Weights]= NodesWeights(PolynomialOrder,GaussianPolynomial)
    N       = PolynomialOrder;
    [T,~]   = GaussianApproximation.Initialization(GaussianPolynomial);
    if T == 2
        Nodes       = -cos((2*(1:N)-1)*pi/(2*N))';
        Weights       = repmat(pi/N,N,1);
    else
        Var     = GaussianApproximation.Polynomial(N+1,GaussianPolynomial);
        Var     = Var(end-1);
        Jac     = jacobian(Var);
        Nodes       = real(double(vpasolve(Var)));    
        if T == 1 
            Weights       = 2./double((1-Nodes.^2).*subs(Jac,Nodes).^2);
        elseif T ==3 
            Weights       = double((2^(N+1)*factorial(N)*sqrt(pi))./(subs(Jac,Nodes).^2));
        elseif T == 4
            Weights       = double(1./(Nodes.*(subs(Jac,Nodes).^2)));
        end
    end
end

%% 4. NUMERICNODESWEIGHTS
% Finds the nodes and weights for a variety of Gaussian polynomials
% numerically. This method is very fast for even high order polynomials as 
% no symbolic calculations are performed. This is done at the expense of 
% accuracy, particularly for the weights. 
%==========================================================================
function [Nodes,Weights]= NumericNodesWeights(PolynomialOrder,GaussianPolynomial)
    N       = PolynomialOrder;
    [T,~]   = GaussianApproximation.Initialization(GaussianPolynomial);
    Fn      = @(X) GaussianApproximation.NumericPolynomial(N,GaussianPolynomial,X);
    
    N= 50;
    T = 3;
    GaussianPolynomial = 'Gauss-Hermite';
    Fn      = @(X) GaussianApproximation.NumericPolynomial(N,GaussianPolynomial,X);
    
    
    if T == 2
        Nodes       = -cos((2*(1:N)-1)*pi/(2*N))';
        Weights     = repmat(pi/N,N,1);
    else
        if T == 1
            Range       = [-1,1];
        end
        if T == 3
            Range       = [-sqrt(4*N+1),sqrt(4*N+1)];
        end
        if T == 4
            Range       = [0,N+(N-1)*sqrt(N)];
        end
        
        % Find root ranges
        GridPrecision = 100000; % This is set exogenously
        IntBi   = linspace(Range(1),Range(2),GridPrecision);
        Roots   = Fn(IntBi);
        Roots   = IntBi([true;diff(sign(Roots{2:(end-1),N+1})) ~= 0;true]);
        RootLen = length(Roots);
        Roots   = [Roots(1:(end-1))',Roots(2:end)'];
        
        % Bisection
        Bisection   = table(Roots(:,1),Roots(:,2),mean(Roots,2),zeros(RootLen-1,1),'VariableNames',{'LoBi','HiBi','Guess','F'});
        itr = 1; thr = Inf;
        while thr > 10^(-16) && itr < 500
            Roots       = Fn(Bisection.Guess);
            Bisection.F = Roots{:,N+1};
            Bisection(mod(1:size(Bisection,1),2)==1,:).F = Bisection(mod(1:size(Bisection,1),2)==1,:).F*-1;
            Bisection.LoBi(Bisection.F<0) = Bisection.Guess(Bisection.F<0);
            Bisection.HiBi(Bisection.F>0) = Bisection.Guess(Bisection.F>0);
            thr = norm(Bisection.Guess-mean([Bisection.LoBi,Bisection.HiBi],2));
            Bisection.Guess = mean([Bisection.LoBi,Bisection.HiBi],2);
            itr = itr + 1;
        end
        LastNode    = Bisection([1,end],:);
        [~,idx]     = min(abs(LastNode.F));
        Nodes       = sort([LastNode.Guess(idx);Bisection.Guess(2:(end-1))]);
        
        if T == 1 
            temp = GaussianApproximation.NumericPolynomial(N+1,GaussianPolynomial,Nodes);
            Weights = (2*(1-Nodes.^2))./((N+1)^2*temp{:,end}.^2);
        end
        if T ==3 
            temp = GaussianApproximation.NumericPolynomial(N+1,GaussianPolynomial,Nodes);
            Weights = (2^(N+1)*factorial(N)*sqrt(pi))./(temp{:,end}.^2);
        end
        if T == 4
            temp = GaussianApproximation.NumericPolynomial(N+1,GaussianPolynomial,Nodes);
            Weights = Nodes./((N+1)^2*temp{:,end}.^2);
        end
    end 
end
    
%% 4. INTERPOLATE
% Given Y, uses M nodes to interpolate an Nth order polynomial.
%==========================================================================
function InterpolatedFunction = Interpolate(YData,PolynomialOrder,MNodes,GaussianPolynomial)
    if length(YData) ~= MNodes
        fprintf('Error: X and Y data do not match')
        return
    end
    N       = PolynomialOrder;
    [X,]    = GaussianApproximation.NodesWeights(MNodes,GaussianPolynomial);
    poly    = GaussianApproximation.Polynomial(N,GaussianPolynomial);
    for i = 1:(N+1)
        Coef(i) = double(sum(YData.*subs(poly(i),X))/sum(subs(poly(i),X).^2));
    end
    InterpolatedFunction = sum(Coef.*poly);
end

    end
end